# JS 中的二进制

## 二进制
**注意**：以下内容，二进制数都是用一个字节—— 8 个二进制位来表示。  

下面是 1 和 -1 的二进制表示，我们称为**真值**。8 位二进制数能表示的真值范围是`[-2⁸, +2⁸]`。  
```js
+ 0000 0001 // +1
- 0000 0001 // -1
```

计算机只能存储 0 和 1，不能存储正负符号，所以用最高位来表示符号，0 为正，1 为负，用剩下位数来表示真值的绝对值，这就是**原码**表示法。原码能表示的范围是`[-2⁷, +2⁷ - 1]`，`1 000 0000` 表示 -0，没有意义，所以这个数字来表示 -128，所以负数比正数多一个。    
```js
0 000 0001 // +1
1 000 0001 // -1
```

**反码**（一补数）是另一种表示数字的方法，规则如下：整数的反码和它的原码一样；负数的反码，原码的符号位不变，其余各位按位取反。反码的表示范围也是 `[-2⁷, +2⁷ - 1]`。  
```js
0 000 0001 // +1
1 111 1110 // -1

0 000 0010 // +2
1 111 1101 // -2
```

**补码**（二补数）主要是为了简化运算，将减法变为加法而发明的数字表示法，规则：整数的补码和原码一样；负数的补码是反码末尾加 1。8 位补码范围也是 `[-2⁷, +2⁷ - 1]`。  
```js
0 000 0001 // +1
1 111 1111 // -1

0 000 0010 // +2
1 111 1110 // -2
```
快速计算负数补码的方法：由其原码低位向高位（从右往左）找到第一个1，1 和其低位（右边）不变，1 前面的高位（左边）按位取反即可。  


## ES 中的二进制整数
ES 中所有数值都以 IEEE 754 **64 位格式**存储，位操作会先把值转换为 **32 位整数**，操作后将结果转换为 64 位。  
有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。  

### 位操作
位操作在数值的底层表示上完成，所以速度会快得多。  
（下面示例用 8 位二进制表示）
#### 1. ~ 按位非
按位非（~，Bitwise NOT）的作用是返回数值的一补数（反码）。  

```js
let numNOT = ~21 // -22
/**
 *  21 = 0001 1001
 * ---------------
 * NOT = 1110 1010 = -22
 */
// numNOT = -21 - 1
```
按位非的最终效果等同于对数值取反并减 1。  

#### 2. & 按位与
按位与（&，Bitwise AND）就是将两个操作数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作（在两个位都是 1 时返回 1，在任何一位是 0 时返回 0）。  

```js
let numAND = 25 & 3 // 1
/**
 *  25 = 0001 1001
 *   3 = 0000 0011
 * ---------------
 * AND = 0000 0001 = 1
 */
```

#### 3. | 按位或
按位或操作（|，Bitwise OR）在至少一位是 1 时返回 1，两位都是 0 时返回 0。
```js
let numOR = 25 | 3 // 27
/**
 *  25 = 0001 1001
 *   3 = 0000 0011
 * ---------------
 *  OR = 0001 1011 = 27
 */
```

#### 4. ^ 按位异或
按位异或（^，Bitwise XOR）与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。
```js
let numXOR = 25 ^ 3 // 26
/**
 *  25 = 0001 1001
 *   3 = 0000 0011
 * ---------------
 * XOR = 0001 1010 = 26
 */
```

#### 5. << 左移
左移（<<，Left Shift）会按照指定的位数将数值的所有位向左移动。（a << n 等同于 a * 2ⁿ）  
```js
let numLS = 3 << 4 // 48
/**
 *   3 = 0000 0011
 * ---------------
 *  LS = 0011 0000 = 48
 */
```
**注意**，左移会保留它所操作数值的符号。`-3 << 4 === -48`  

#### 6. >> 有符号右移
有符号右移（>>，Signed Right Shift）会将数值都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。（a >> n 等同于 a / 2ⁿ 并向下取整）  
```js
let numSRS = 5 >> 2 // 1
/**
 *   5 = 0000 0101
 * ---------------
 * SRS = 0000 0001 = 1
 */
```

#### 7. >>> 无符号右移
无符号右移（>>>，Unsigned Right Shift）也会将数值向右移。  
对于正数，无符号右移与有符号右移结果相同。   
```js
let nuURS = 5 >> 2 // 1
/**
 *   5 = 0000 0101
 * ---------------
 * URS = 0000 0001 = 1
 */
```

对于负数，无符号右移会变成正数。  
```js
let nuURS = -5 >> 30 // 3
/**
 *  -5 = 1111 1111 1111 1111 1111 1111 1111 1010
 * ---------------------------------------------
 * URS = 0000 0000 0000 0000 0000 0000 0000 0011
 */
```

### 位操作的范围
对 JS 中对任何数字做位运算，都会被转为整形。  
```js
2.1 | 0 // 2
```

根据上面的知识推断二进制整数的表示范围是 `[-2³¹, +2³¹ - 1]`([-2147483648, +2147483647])。  
```js
let max = Math.pow(2, 31) - 1 // 2147483647
max |= 0 // 2147483647
max += 1 // 2147483648
max |= 0 // -2147483648
max |= 0 // -2147483648
max -= 1 // -2147483649
max |= 0 // 2147483647
```
超过最低和最高的值再去进行转换时都将改变正负号。  