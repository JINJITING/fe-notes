(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{370:function(t,s,a){"use strict";a.r(s);var n=a(44),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"闭包-closure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包-closure"}},[t._v("#")]),t._v(" 闭包/Closure")]),t._v(" "),a("h2",{attrs:{id:"闭包的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的定义"}},[t._v("#")]),t._v(" 闭包的定义")]),t._v(" "),a("h3",{attrs:{id:"mdn-的闭包定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mdn-的闭包定义"}},[t._v("#")]),t._v(" MDN 的闭包定义")]),t._v(" "),a("blockquote",[a("p",[t._v("A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time."),a("br"),t._v("\n一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。")])]),t._v(" "),a("h3",{attrs:{id:"js-高级程序设计第-4-版的闭包定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-高级程序设计第-4-版的闭包定义"}},[t._v("#")]),t._v(" JS 高级程序设计第 4 版的闭包定义")]),t._v(" "),a("blockquote",[a("p",[t._v("The terms anonymous functions and closures are often incorrectly used interchangeably. Closures are functions that have access to variables from another function’s scope."),a("br"),t._v("\n匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数。")])]),t._v(" "),a("p",[t._v("（上面两种说法中的共同点就是闭包可以访问到外层作用域。在 JS 中，函数内部是能直接读取全局变量的，从这点上来说，JS 中的函数和闭包是一起出现的。）")]),t._v(" "),a("h3",{attrs:{id:"其他定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他定义"}},[t._v("#")]),t._v(" 其他定义")]),t._v(" "),a("blockquote",[a("p",[t._v("在 JavaScript 中，根据词法作用域规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。")])]),t._v(" "),a("blockquote",[a("p",[t._v("ECMAScript中，闭包指的是：")]),t._v(" "),a("ol",[a("li",[t._v("从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。")]),t._v(" "),a("li",[t._v("从实践角度：以下函数才算是闭包："),a("br"),t._v("\ni. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）"),a("br"),t._v("\nii. 在代码中引用了自由变量")])])]),t._v(" "),a("p",[t._v("（https://github.com/mqyqingfeng/Blog/issues/9）")]),t._v(" "),a("h2",{attrs:{id:"闭包的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的应用"}},[t._v("#")]),t._v(" 闭包的应用")]),t._v(" "),a("h3",{attrs:{id:"_1-柯里化函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-柯里化函数"}},[t._v("#")]),t._v(" 1. 柯里化函数")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])])}),[],!1,null,null,null);s.default=e.exports}}]);